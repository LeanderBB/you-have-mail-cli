use crate::notifiers::NTFYConfig;
use crate::secrets::SecretsType;
use crate::utils;
use anyhow::anyhow;
use log::info;
use serde::Deserialize;
use std::path::Path;

#[derive(Deserialize)]
pub struct Config {
    pub secrets: SecretsType,
    pub poll_interval: u64,
    pub stdout_notifier: bool,
    #[serde(default = "_default_false")]
    pub accept_plain_secrets_insecure: bool,
    pub account: Option<Vec<Account>>,

    #[cfg(feature = "notifier-ntfy")]
    pub ntfy: Option<Vec<NTFYConfig>>,
}

impl Config {
    pub fn has_notifiers(&self) -> bool {
        let mut result = false;
        if self.stdout_notifier {
            result = true;
        }

        #[cfg(feature = "notifier-ntfy")]
        if let Some(pushers) = &self.ntfy {
            result = result || !pushers.is_empty();
        }

        result
    }
}

#[derive(Deserialize)]
pub struct Account {
    pub email: String,
    pub backend: String,
}

const fn _default_false() -> bool {
    false
}

pub fn load_config(dir: impl AsRef<Path>, create_if_not_exist: bool) -> anyhow::Result<Config> {
    let config_file = dir.as_ref().join("config.toml");
    info!("Loading config from {:?}", config_file);

    if !config_file.exists() && create_if_not_exist {
        info!("Config does not exist, creating default placeholder");
        let default_config = r#"# Default Config Generated by you-have-mail-cli

# Secret storage type (Plain, Keyring)
secrets="Keyring"
# List of notifiers
notifiers=["StdOut"]
# Poll interval of the observer in seconds
poll_interval=300
# If using Plain secret storage, this must be set to true so you consent to the risks
#accept_plain_secrets_insecure=true
# Set to true if you wish to write notifications to stdout
stdout_notifier="false"

# For each account create on entry such as the one below:
#[[account]]
#email = "@proton.me"
#backend ="Proton Mail"
"#;
        utils::write_user_file(&config_file, default_config.as_bytes())
            .map_err(|e| anyhow!("Failed to write default config: {e}"))?;
    }

    let config = config::Config::builder()
        .add_source(config::File::from(config_file.as_path()))
        .build()
        .map_err(|e| anyhow!("Failed to load config: {e}"))?;
    config
        .try_deserialize::<Config>()
        .map_err(|e| anyhow!("Failed to deserialize config: {e}"))
}
